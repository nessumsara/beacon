<?php
/**
 * Implements hook_field_info().
 *
 * Provides the description of the field.
 */
function pollfield_field_info() {

  return array(
    // We name our field as the associative name of the array.
    'pollfield_poll' => array(//this is name of field that evetrhing else is connected
      'label' => t('Pollfield module'),
      'description' => t('This is to store poll as a field and not as a node.'),
      'default_widget' => 'pollfield_main',//each field can have many widget
      'default_formatter' => 'pollfield_default',
    ),
  );
	
}
/*
 * Implements hook_field_validate().
 *
 * This hook gives us a chance to validate content that's in our
 * field. We're really only interested in the $items parameter, since
 * it holds arrays representing content in the field we've defined.
 * We want to verify that the items only contain RGB hex values like
 * this: #RRGGBB. If the item validates, we do nothing. If it doesn't
 * validate, we add our own error notification to the $errors parameter.
 *
 * @see field_example_field_widget_error()
 */
function pollfield_field_validate($entity_type, $entity, $field, $instance, $langcode, $items, &$errors) {
  foreach ($items as $delta => $item) {
    
    
  }
}

/**
 * Implements hook_field_is_empty().
 *
 * hook_field_is_emtpy() is where Drupal asks us if this field is empty.
 * Return TRUE if it does not contain data, FALSE if it does. This lets
 * the form API flag an error when required fields are empty.
 */
function pollfield_field_is_empty($item, $field) {
	//for now field are always full
  return FALSE;
}

/**
 * Implements hook_field_formatter_info().
 *
 * We need to tell Drupal that we have two different types of formatters
 * for this field. One will change the text color, and the other will
 * change the background color.
 *
 * @see field_example_field_formatter_view()
 */
function pollfield_field_formatter_info() {
	
  return array(
    // This formatter just displays the hex value in the color indicated.
    'pollfield_default' => array(
      'label' => t('Default'),
      'field types' => array('pollfield_poll'),
    ),
    // This formatter changes the background color of the content region.
    'pollfield_choice' => array(
      'label' => t('Only choices'),
      'field types' => array('pollfield_poll'),
    ),
    // This formatter changes the background color of the content region.
    'pollfield_question' => array(
      'label' => t('Only questions'),
      'field types' => array('pollfield_poll'),
    ),
    'pollfield_results' => array(
      'label' => t('Only results'),
      'field types' => array('pollfield_poll'),
    ),
    'pollfield_runtime' => array(
      'label' => t('Only runtime'),
      'field types' => array('pollfield_poll'),
    ),
  );
}

/**
 * hook field create
 * used to serialize some pollfield settings
 */
 function pollfield_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
 		
		foreach ($items as $delta=>$item){
			//poll settings
			$poll_settings['poll_type'] = $item['poll_type'];
			$poll_settings['delete_votes'] = $item['delete_votes'];
			$poll_settings['cancelvote_allow'] = $item['cancelvote_allow'];
			$poll_settings['result_allow'] = $item['result_allow'];
			$items[$delta]['poll_features'] = serialize($poll_settings);
			//chioces
			//delete empty choices
			$choices_items=array();
			foreach ($item['group'] as $key => $value) {
				if (strlen($value['choice'])<2){
					
				}else{
					$choices_items[]=$value;
				}
			}
			$choices=serialize($choices_items);
			$items[$delta]['choice'] = $choices; 
		}
 }
 
/**
 * Implements hook_field_formatter_view().
 *
 * Two formatters are implemented.
 * - field_example_simple_text just outputs markup indicating the color that
 *   was entered and uses an inline style to set the text color to that value.
 * - field_example_color_background does the same but also changes the
 *   background color of div.region-content.
 *
 * @see field_example_field_formatter_info()
 */
function pollfield_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
	
  switch ($display['type']) {
    // This formatter simply outputs the field as text and with a color.
    case 'pollfield_default':
      foreach ($items as $delta => $item) {
      	$elements['item']=$item;
				$elements['entity']=$entity;
				$elements['delta']=$delta;
				$elements['field']=$field;
      	$output=theme('pollfield_default_formatter',array('elements'=>$elements));
        $element[$delta] = array(
          // We create a render array to produce the desired markup,
          // "<p style="color: #hexcolor">The color code ... #hexcolor</p>".
          // See theme_html_tag().
          '#markup' => $output,
        );
      }
      break;

    // This formatter adds css to the page changing the '.region-content' area's
    // background color. If there are many fields, the last one will win.
    case 'pollfield_choices':
      foreach ($items as $delta => $item) {
         $element[$delta] = array(
          // We create a render array to produce the desired markup,
          // "<p style="color: #hexcolor">The color code ... #hexcolor</p>".
          // See theme_html_tag().
          '#type' => 'html_tag',
          '#tag' => 'p',
          '#value' => t('This is choices formater'),
        );
      }
      break;
			case 'pollfield_question':
      foreach ($items as $delta => $item) {
         $element[$delta] = array(
          // We create a render array to produce the desired markup,
          // "<p style="color: #hexcolor">The color code ... #hexcolor</p>".
          // See theme_html_tag().
          '#type' => 'html_tag',
          '#tag' => 'p',
          '#value' => t('This is defualt formater'),
        );
      }
      break;
			case 'pollfield_results':
      foreach ($items as $delta => $item) {
         $element[$delta] = array(
          // We create a render array to produce the desired markup,
          // "<p style="color: #hexcolor">The color code ... #hexcolor</p>".
          // See theme_html_tag().
          '#type' => 'html_tag',
          '#tag' => 'p',
          '#value' => t('This is results formater'),
        );
      }
      break;
			case 'pollfield_runtime':
      foreach ($items as $delta => $item) {
         $element[$delta] = array(
          // We create a render array to produce the desired markup,
          // "<p style="color: #hexcolor">The color code ... #hexcolor</p>".
          // See theme_html_tag().
          '#type' => 'html_tag',
          '#tag' => 'p',
          '#value' => t('This is runtime formater'),
        );
      }
      break;
  }

  return $element;
}
/**
 * Implements hook_field_widget_info().
 *
 * Three widgets are provided.
 * - A simple text-only widget where the user enters the '#ffffff'.
 * - A 3-textfield widget that gathers the red, green, and blue values
 *   separately.
 * - A farbtastic colorpicker widget that chooses the value graphically.
 *
 * These widget types will eventually show up in hook_field_widget_form,
 * where we will have to flesh them out.
 *
 * @see field_example_field_widget_form()
 */
function pollfield_field_widget_info() {
  return array(
    'pollfield_main' => array(
      'label' => t('Pollfield'),
      'field types' => array('pollfield_poll'),
    ),
  );
}
/**
 * Implements hook_field_widget_form().
 *
 * hook_widget_form() is where Drupal tells us to create form elements for
 * our field's widget.
 *
 * We provide one of three different forms, depending on the widget type of
 * the Form API item provided.
 *
 */
function pollfield_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $value = isset($items[$delta]['question']) ? $items[$delta]['question'] : '';
	
  $widget = $element;
  $widget['#delta'] = $delta;

  switch ($instance['widget']['type']) {

    case 'pollfield_main':
			
			//question 
      $widget['question'] = array(
        '#type' => 'textfield',
        '#title' => t('Question'),
        '#default_value'=>$value,
      );
			//status
			$admin_pollfield=TRUE;
			$_active = array(0 => t('Closed'), 1 => t('Active'));
		  $widget['active']= array(
		    '#type' => 'radios',
		    '#access' => $admin_pollfield,
		    '#title' => t('Status'),
		    // If no value exists, always default to active (1)
		    '#default_value' => isset($items[$delta]['active']) ? $items[$delta]['active'] : 0,
		    '#options' => $_active,
		    '#description' => t('When a pollfield is closed, visitors can no longer vote for it.')
		  );
			 //runtime - duration
			 $widget['runtime'] = array(
		    '#type' => 'select',
		    '#access' => $admin_pollfield,
		    '#title' => t('Duration'),
		    // If no value exists, always default to Unlimited (0)
		    '#default_value' => isset($items[$delta]['runtime']) ? $items[$delta]['runtime'] : 0,
		    '#options' => pollfield_duration_options(),
		    '#description' => t('After this period, the pollfield will be closed automatically.')
		   );
			 //anonymous voting
			$widget['anonymous'] = array(
		    '#type' => 'select',
		    '#access' => $admin_pollfield,
		    '#title' => t('Anonymous voting'),
		    // If no value exists, always default to Not allowed (anon_non)
		    '#default_value' => isset($items[$delta]['anonymous']) ? $items[$delta]['anonymous'] : 'anon_non',
		    '#options' => array(
		      'anon_non' => t('Not allowed'),
		      'anon_by_ip' => t('Allowed, filtered by user IP'),
		      'anon_by_cookie' => t('Allowed filtered by user cookie'),
		      'anon_all' => t('Allowed')
		    ),
		    '#description' => t('Allow or disallow anonymous users to vote on this poll. Filtering by user IP or cookie ensures only one vote is allowed per user IP.')
		  );
			//cancel permission 
			$_cancelvote = array(0 => t('Disallow'), 1 => t('Allow'));
			$widget['cancelvote_allow'] = array(
		    '#type' => 'radios',
		    '#access' => $admin_pollfield,
		    '#title' => t('Cancel Vote'),
		    '#default_value' => isset($items[$delta]['cancelvote_allow']) ? $items[$delta]['cancelvote_allow'] : 1,
		    '#options' => $_cancelvote,
		    '#description' => t('Allow or disallow "Cancel vote" button. "Cancel vote" button allows voters to cancel their vote and choose a different one if they want.'),
		  );
			//show result befora voting
			$_cancelvote = array(0 => t('Disallow'), 1 => t('Allow'));
		  $widget['result_allow'] = array(
		    '#type' => 'radios',
		    '#access' => $admin_pollfield,
		    '#title' => t('Show results before voting'),
		    '#default_value' => isset($items[$delta]['cancelvote_allow']) ? $items[$delta]['cancelvote_allow'] : 0,
		    '#options' => $_cancelvote,
		    '#description' => t('Allow or disallow users to see current poll results before voting on this poll. If set to disallow, anonymous users can never see the results. Permissions under pollfield module override this setting.'),
		  );
		
		  // Poll type
		  // Can users vote on multiple choices or just one?
		  $_poll_type = array(0 => t('Single choice'), 1 => t('Multiple choice'));
		  $widget['poll_type'] = array(
		    '#type' => 'radios',
		    '#title' => t('Poll type'),
		    '#default_value' => isset($poll_type) ? $poll_type : 1,
		    '#options' => $_poll_type,
		    '#description' => t('In a Single choice poll only one of the responses can be voted for while in a Multiple choice poll it is possible to choose more than one at the same time.'),
		  );
			//delete votes from this poll
			$_delete_votes = array(0 => t('Not delete'), 1 => t('Delete'));
		  $widget['delete_votes'] = array(
		    '#type' => 'checkbox',
		    '#title' => t('Delete all votes'),
		    '#description' => t('Delete all votes on this poll. THIS ACTION CAN NOT BE UNDONE!'),
		    '#default_value' => 0,
		    '#access' => $admin_pollfield,
		  );
			
			//serialize features
			$widget['poll_features']= array(
		    '#type' => 'hidden',
		    '#value' => isset($items[$delta]['poll_features']) ? $items[$delta]['poll_features'] : 0,
		  );
			$widget['choice']= array(
		    '#type' => 'hidden',
		    '#value' => isset($items[$delta]['choice']) ? $items[$delta]['choice'] : 0,
		  );
			
			//choices
			$choices = unserialize($items[$delta]['choice']);	
			$number_of_choices = count($choices);
			$number_in_data_base = count($choices);
			//ajax wrapper
			$wrapper = 'ajax-wrapper-pollfield-'.$form_state['node']->nid.'-'.$delta;
			$field_name = $field['field_name'];
			
			if (!isset($form_state['count_choices'])){
				$form_state['count_choices']=$number_of_choices;	
			}else{
				$number_of_choices=$form_state['count_choices'];
			}
			//forming field definition for form return in ajax
		 	$form_state['field_name']=$field_name;
			
		  foreach ($form['#node']->$field_name as $lang => $fileds){
		  	$field_lang=$lang;
		  }
			$form_state['field_lang']=$field_lang;
			$form_state['field_delta']=$delta;
			
			
			
			
			$widget['group'] = array(
	        '#prefix' => '<div id="'.$wrapper.'">',
	        '#suffix' => '</div>',
	    );
			$count_chioces=0;
			
			for ($i=0;$i<$number_of_choices+1;$i++){
				
				if (true){
					$widget['group'][$count_chioces] = array(
		        '#type' => 'fieldset',
		        '#title' => t('Choice #%delta', array('%delta' => intval($i + 1))),
		        '#tree' => TRUE,
		       	'#description' => t('If you want to delete it just delete text from Response textfield.')
		      );
					if ($count_chioces<$number_in_data_base){
						$defaule_value = isset($choices[$i]['choice']) ? $choices[$i]['choice'] : '';
					}
					else {
						$defaule_value = '';
					}
		      $widget['group'][$count_chioces]['choice'] = array(
		        '#title' => t('Response'),
		        '#type' => 'textfield',
		        '#default_value' => $defaule_value,
		        '#rows' => 2,
		        '#weight' => $count_chioces,
		      
		      );
					
					if ($count_chioces<$number_in_data_base){
						$defaule_value = isset($choices[$count_chioces]['votes']) ? $choices[$count_chioces]['votes'] : '';
					}
					else {
						$defaule_value = '';
					}
		      $widget['group'][$count_chioces]['votes'] = array(
		        '#title' => t('Starting votes count (optional)'),
		        '#access' => $admin_pollfield,
		        '#type' => 'textfield',
		        '#default_value' => $defaule_value,
		        '#element_validate' => array('_pollfield_is_digits_validate'),
		       
		        '#size' => 10,
		        '#weight' => $count_chioces+1,
		      );
					
					$count_chioces++;
	      }
			}
		
			
			
			$widget['add-more'] = array(
	      '#type' => 'submit',
	      '#value' => t('More choices'),
	      '#description' => t("If the amount of boxes above isn't enough, click here to add more choices."),
	      '#submit'=>array('pollfield_more_choice_callback_submit'),
	      
	      '#ajax' => array(
		      // #ajax has two required keys: callback and wrapper.
		      // 'callback' is a function that will be called when this element changes.
		      'callback' => 'pollfield_more_choice_callback_js',
		      // 'wrapper' is the HTML id of the page element that will be replaced.
		      'wrapper' => $wrapper,
		      // There are also several optional keys - see ajax_example_autocheckboxes
		      // below for details on 'method', 'effect' and 'speed' and
		      // ajax_example_dependent_dropdown for 'event'.
	     	),
    	);
			
			break;
   
  }
	
	//question is name of field in field database
  $element['question'] = $widget['question'];
	$element['active'] = $widget['active'];
	$element['anonymous'] = $widget['anonymous'];
	$element['runtime']= $widget['runtime'];
	$element['poll_type']= $widget['poll_type'];
	$element['cancelvote_allow'] = $widget['cancelvote_allow'];
	$element['result_allow'] = $widget['result_allow'];
	$element['delete_votes'] = $widget['delete_votes'];
	$element['group'] = $widget['group'];
	$element['add-more'] = $widget['add-more'];
	//hidden elements for serialized fields
	$element['poll_features'] = $widget['poll_features'];
	$element['choice'] = $widget['choice'];
	return $element;
}

/**
 * ajax more choice callback
 */
function pollfield_more_choice_callback_js($form, $form_state){
	$field_name = $form_state['field_name'];
	$field_lang = $form_state['field_lang'];
	$field_delta = $form_state['field_delta'];
	$form_choices = $form[$field_name][$field_lang][$field_delta]['group'];
	
	return $form_choices;
}
 
/**
 * submit more choice callback
 */
function pollfield_more_choice_callback_submit($form, &$form_state){
	$form_state['count_choices']=$form_state['count_choices']+1;

	$form_state['rebuild'] = TRUE;
}

/**
 * Implements hook_field_widget_error().
 *
 * hook_field_widget_error() lets us figure out what to do with errors
 * we might have generated in hook_field_validate(). Generally, we'll just
 * call form_error().
 *
 * @see field_example_field_validate()
 * @see form_error()
 */
function pollfield_field_widget_error($element, $error, $form, &$form_state) {
	
  switch ($error['error']) {
    case 'field_example_invalid':
      form_error($element, $error['message']);
      break;
  }
}


/**
 * Implements hook_menu().
 *
 * Provides a simple user interface that tells the developer where to go.
 */
function pollfield_menu() {
  $items = array();
  $items['pollfield/add_choice'] = array(
    'title' => 'Add choice',
    'page callback' => 'pollfield_add_choice',
    'access arguments' => array('access content'),
    'type' => MENU_CALLBACK,
  );
  return $items;
}
/**
 * Save vote vote information.
 *
 * @param $form_values
 *   Array of input to the vote form.
 * @param $type
 *   String of the vote type. Single or multiple choice.
 * @param $cookie_db
 *   User cookie information. Used for voter checking.
 *
 * @return
 *   Always seems to return FALSE
 *   :TODO: figure out if this should return something more valuable
 */
function pollfield_save_choice($vote, $node) {

  $voted = FALSE;

 	$table =  'field_revision_'.$vote->field_name;
	$table_data = 'field_data_'.$vote->field_name;
  // Get total votes
  $field_votes = $vote->field_name .'_votes';
  $query = "SELECT ".$field_votes." FROM {".$table."} WHERE entity_id = ".$vote->nid." AND delta = ".$vote->field_name_delta;
  $total_votes = db_query($query)->fetchField();
 
	$vote->table=$table;
  // Make sure the voter filled out the poll form correctly.
  $vote_error = FALSE;
  if ($vote->type == 'single' && !isset($vote->choice)) {
    $vote_error = TRUE;
  }
  else {
    $choices_selected = count($vote->choice);
    if ($choices_selected == 0) {
      $vote_error = TRUE;
    }
  }
  if ($vote_error) {
    drupal_set_message(t('Choice is not selected. Select your answer and vote.'));
    return 0;
  }
	
  // Check if the user has already voted on this pollfield
  $elements['entity']=$node;$elements['field']['field_name']=$vote->field_name;$elements['delta']=$vote->field_name_delta;
	$elements['item']=$vote->item;
  $voted = pollfield_user_voted($elements);

  if ($voted == 0) {

    // Save a single vote or pass or loop through an array of votes
    // to save for multiple choice polls
    if ($vote->type == 'single') {
      $choice = $vote->choice;
      $record_vote = pollfield_save_vote_record($vote, $choice);
    }
    else {
      $choices = $vote->choice;
      foreach ($choices as $choice) {
        $record_vote = pollfield_save_vote_record($vote, $choice);
      }
    }

    // Increment total votes for this pollfield
    $total_votes++;
   	$query = "UPDATE {".$table."} SET ".$field_votes." = ".$total_votes." WHERE entity_id = ".$vote->nid." AND delta=".$vote->field_name_delta;
    db_query($query);
		$query = "UPDATE {".$table_data."} SET ".$field_votes." = ".$total_votes." WHERE entity_id = ".$vote->nid." AND delta=".$vote->field_name_delta;
    db_query($query);
   
    // Any time a vote is recorded, clear the CCK cache so the votes can be updated.
    pollfield_clear($node);

    drupal_set_message(t('Your vote was recorded.'));
  }
  else {
    drupal_set_message(t('You already voted or you are not allowed to vote'), 'error');
  }
  return 0;
}

/**
 * Write a vote to the database
 */
function pollfield_save_vote_record($vote, $choice) {

  // Store user id if the user is logged in
  if ($vote->uid > 0) {
    db_query("INSERT INTO {pollfield_votes} (nid, field_table, field_name, uid, delta, field_name_delta)
      VALUES (:nid, :table, :field_name , :uid, :choice, :delta)",
      array(':nid'=>$vote->nid, ':table'=>$vote->table, ':field_name'=>$vote->field_name, ':uid'=>$vote->uid, ':choice'=>$choice, ':delta'=>$vote->field_name_delta));
  }
  // Store IP or cookie if the user is anonymous
  else {
  	db_query("INSERT INTO {pollfield_votes} (nid, field_table, field_name, uid, delta, hostname, field_name_delta, cookie)
      VALUES (:nid, :table, :field_name , :uid, :choice, :hostename, :delta, :cookie)",
      array(':nid'=>$vote->nid, ':table'=>$table, ':field_name'=>$vote->field_name, ':uid'=>$vote->uid, ':choice'=>$choice, 
      			'hostname:'=>$vote->hostname,':delta'=>$vote->field_name_delta, ':cookie'=>$vote->cookie));
			
    db_query("INSERT INTO {pollfield_votes} (nid, field_table, field_name, delta, hostname, field_name_delta, cookie)
      VALUES (%d, '%s', '%s', %d, '%s', %d, '%s')",
      $vote->nid, $vote->field_table, $vote->field_name, $choice, $vote->hostname, $vote->field_name_delta, $vote->cookie);
  }
}

/**
 * Cancel a user's vote on a poll
 */
function pollfield_cancel_choice($vote) {


  // Get total votes
  $field_votes = $vote->field_name .'_votes';
	$table = 'field_revision_'.$vote->field_name;
	$table_data = 'field_data_'.$vote->field_name;
	$query = "SELECT ".$field_votes." FROM {".$table."} WHERE entity_id=".$vote->nid." AND delta=".$vote->field_name_delta;
  $total_votes = db_query($query)->fetchField();
  

  // Cancel all the votes by this user on this poll
  $cancel_vote = pollfield_cancel_vote_record($vote);

  // Decrement total votes for this pollfield
  $total_votes--;
 
	$query="UPDATE {".$table."} SET ".$field_votes."=".$total_votes." WHERE entity_id=".$vote->nid." AND delta=".$vote->field_name_delta;
  db_query($query);
  $query="UPDATE {".$table_data."} SET ".$field_votes."=".$total_votes." WHERE entity_id=".$vote->nid." AND delta=".$vote->field_name_delta;
  db_query($query);
 
  return 0;
}

/**
 * Delete votes from the database
 *
 * Delete votes made by a specific user on a
 * specific pollfield.
 *
 * @param $vote
 *   Vote object
 */
function pollfield_cancel_vote_record($vote) {

  if ($vote->uid) {
    db_query("DELETE from {pollfield_votes}
      WHERE nid = :nid AND field_table=:field_table AND field_name=:field_name AND uid = :uid AND field_name_delta=:field_name_delta",
      array(':nid'=>$vote->nid, ':field_table'=>$vote->field_table, ':field_name'=>$vote->field_name, ':uid'=>$vote->uid, 
      			':field_name_delta'=>$vote->field_name_delta));
  }
  else {
    if ($vote->anonymous == 'anon_by_ip') {
      db_query("DELETE from {pollfield_votes}
        WHERE nid = :nid AND field_table=:field_table AND field_name=:field_name AND hostname = :hostname AND field_name_delta=:field_name_delta",
        array(':nid'=>$vote->nid, ':field_table'=>$vote->field_table, 'field_name'=>$vote->field_name,':hostname'=>$vote->hostname, ':field_name_delta'=>$vote->field_name_delta));
    }
    if ($vote->anonymous == 'anon_by_cookie') {
      db_query("DELETE from {pollfield_votes}
        WHERE nid = :nid AND field_table=:field_table AND field_name=:field_name AND cookie = :cookie AND field_name_delta=:field_name_delta",
        array(':nid'=>$vote->nid, ':field_table'=>$vote->field_table, ':field_name'=>$vote->field_name, 
        ':cookie'=>$vote->cookie, ':field_name_delta'=>$vote->field_name_delta));
    }
  }
}
	
/**
 * Saving or canceling user poll vote.
 */
function pollfield_vote() {
  $form_values = $_POST;

  // Build vote object
  $vote->nid = $form_values['nid'];
  $vote->field_name = $form_values['field_name'];
  $vote->field_name_delta = $form_values['field_name_delta'];
  $vote->field_table = $form_values['table'];
  $vote->cancel = $form_values['cancel'];
  if (isset($form_values['choice']))
  	$vote->choice = $form_values['choice'];
	$item = unserialize($form_values['item']);
	$vote->item = $item;
  // Information about the voter
  global $user;
  $vote->uid = $user->uid;
  $vote->hostname = $_SERVER['REMOTE_ADDR'];

  // If we need a cookie add it here
  $cookie = pollfield_cookie_id_generator();
  if ($cookie != 0) {
    $vote->cookie = serialize($cookie);
  }
  else {
    $vote->cookie = $cookie;
  }

  $node = node_load($vote->nid);

  

  // Get poll features
  $field_name = $vote->field_name;
  $field = $node->$field_name;
  $poll_features = unserialize($item['poll_features']);
  $vote->anonymous = $item['anonymous'];

  // Cancel vote
  if ($vote->nid && $vote->cancel == 1) {
    pollfield_cancel_choice($vote);
  }

  // Vote
  if ($vote->nid && $vote->cancel == 0) {
    if ($poll_features['poll_type'] == '0') {
      $vote->type = 'single';
    }
    if ($poll_features['poll_type'] == '1') {
      $vote->type = 'multiple';
    }
    pollfield_save_choice($vote, $node);
  }
	/*
  // Reload the pollfield page
  $query=$_GET['q'];
  if (isset($_GET['page']))
    $page='page='. $_GET['page'];
  drupal_goto($query, $page, 'pollfield-'. $vote->nid .'-'. $vote->field_name_delta);
	*/
  // Clear the cache
  pollfield_clear($node);

}

/**
 * Cookie generator for anonymous voting.
 */
function pollfield_cookie_id_generator() {
  global $user;
  $form_values = $_POST;
  $nid = $form_values['nid'];
  $field_name = $form_values['field_name'];
  $field_name_delta = $form_values['field_name_delta'];
  $field_table = $form_values['table'];
	$item = $form_values['item'];
  $node = node_load($nid);
  $user_id_cookie = rand(0, 100000);
  $user_id_cookie = $user_id_cookie+time();
  $user_id_cookie = 'id'. $user_id_cookie;
  // /cookie add***************************************
  $cookie_name = $field_table .'_'. $field_name .'_'. $field_name_delta;
  $cookie_value = $user_id_cookie;
  $field = $node->$field_name;
  $duration = $item['runtime'];

  $anonymous = $item['anonymous'];

  if ($anonymous != 'anon_by_cookie') {
    return 0;
  }

  if (!isset($_COOKIE[$cookie_name])) {
    if ($duratione == 0) {
      $expire = time()+60*60*24*30;// if poll is unlimited set expire one month
    }
    else {
      $expire = time()+$duration;
    }
    setcookie($cookie_name, $cookie_value, $expire, '/');
    $cookie = array('cookie_name' => $cookie_name, 'cookie_value' => $cookie_value);
  }
  else {
    $cookie = array('cookie_name' => $cookie_name, 'cookie_value' => $_COOKIE[$cookie_name]);
  }
  // /*************************************************

  return $cookie;
}

/**
 * Check if user has voted on a specific pollfield.
 *
 * @return
 *   Integer of the number of votes.
 *   0 if they haven't voted.
 */
function pollfield_user_voted($elements) {
  global $user;
	
	$node=$elements['entity'];
	
	$field_name = $elements['field']['field_name'];
	$field_table = 'field_revision_'.$field_name;
	$field_name_delta = $elements['delta'];
	
  $nid = $node->nid;
  $uid = $user->uid;
  $hostname = $_SERVER['REMOTE_ADDR'];
  $voted = FALSE;
	$is_voted = 0;
  $tnid = db_query("SELECT tnid FROM {node} WHERE nid=:nid", array(':nid'=>$nid))->fetchField();
	
  if ($tnid==0) {//there is no translation
    $t_nodes_results=db_query("SELECT nid FROM {node} WHERE nid = :nid", array(':nid'=>$nid));
  }
  else { //there is translation
    $t_nodes_results=db_query("SELECT nid FROM {node} WHERE tnid = :tnid", array(':tnid'=>$tnid->tnid));
  }
	
  while ($t_nodes = $t_nodes_results->fetchObject()) {//check all translations
    $t_nid=$t_nodes->nid;

    // Get anonymous vote settings
    $field = $elements['item'];
    $anonymous = $field['anonymous'];

    // check if user has voted
    if ($user->uid) {
      $voted = db_query("SELECT count(*) FROM {pollfield_votes}
        WHERE nid = :nid AND field_table=:field_table AND field_name=:field_name AND uid = :uid AND field_name_delta=:field_name_delta",
        array(':nid'=>$t_nid, ':field_table'=>$field_table, ':field_name'=>$field_name, ':uid'=>$user->uid, ':field_name_delta'=>$field_name_delta))->fetchField();// delta is number of choice
        
    }
    else {// user is anonymous
      if ($anonymous == 'anon_by_ip') {
        $voted = db_query("SELECT count(*) from {pollfield_votes}
          WHERE nid = :nid AND field_table= :field_table AND field_name= :field_name AND hostname = :hostname AND field_name_delta= :field_name_delta",
          array(':nid'=>$t_nid, ':field_table'=>$field_table, ':field_name'=>$field_name, ':hostname'=>$hostname, ':field_name_delta'=>$field_name_delta))->fetchField();// delta is number of choice
      }
      if ($anonymous == 'anon_non') {
        // $voted = 0;
      }
      if ($anonymous == 'anon_all') {
        // $voted = 1;
      }
      if ($anonymous == 'anon_by_cookie') {
        // add cookie
        $cookie_name = $field_table .'_'. $field_name .'_'. $field_name_delta;
        $cookie_collected_value = $_COOKIE[$cookie_name];

        $cookie_compare = array('cookie_name' => $cookie_name, 'cookie_value' => $cookie_collected_value);

        $cookie_compare_db = serialize($cookie_compare);

        $voted = db_query("SELECT count(*) from {pollfield_votes}
          WHERE nid = :nid AND field_table= :field_table AND field_name = :field_name AND cookie = :cookie AND field_name_delta=:field_name_delta",
          array(':nid'=>$t_nid, ':field_table'=>$field_table, ':field_name'=>$field_name, ':cookie'=>$cookie_compare_db, ':field_name_delta'=>$field_name_delta));
      }
    }
    $is_voted=$is_voted+$voted;
  }

  return $is_voted;
}

/**
 * Get user votes.
 *
 * @return
 *   Returns an array of votes for theme functions.
 */
function pollfield_user_votes($elements) {
  global $user;
	$node = $elements['entity'];
  $nid = $node->nid;
  $uid = $user->uid;
  $hostname = $_SERVER['REMOTE_ADDR'];
  $voted = FALSE;
	
	$field_name = $elements['field']['field_name'];
	$field_table = 'field_revision_'.$field_name;
	$field_name_delta = $elements['delta'];
	
  // get table
  $votes=array();
  $tnid = db_query("SELECT tnid FROM {node} WHERE nid=:nid", array('nid'=>$nid))->fetchField();
  if ($tnid==0) { //there is no translation
    $t_nodes_results=db_query("SELECT nid FROM {node} WHERE nid = :nid", array('nid'=>$nid));
  }
  else { //there is translation
    $t_nodes_results=db_query("SELECT nid FROM {node} WHERE tnid = :nid", array('nid'=>$tnid));
  }
	
  while ($t_nodes = $t_nodes_results->fetchObject()) {//check all translations
    $t_nid=$t_nodes->nid;
    // Get anonymous vote settings
    $field = $elements['item'];
    $anonymous = $field['anonymous'];

    // get user votes
    if ($user->uid) {
      $result = db_query("SELECT delta FROM {pollfield_votes}
        WHERE nid = :nid AND field_table= :field_table AND field_name= :field_name AND uid = :uid AND field_name_delta=:field_name_delta",
        array(':nid'=>$t_nid, ':field_table'=>$field_table, ':field_name'=>$field_name, ':uid'=>$user->uid, ':field_name_delta'=>$field_name_delta));// delta is number of choice
      while ($db_votes = $result->fetchObject()) {
        $votes[] = $db_votes->delta;
      }
			
    }
    // user is anonymous
    else {
      if ($anonymous == 'anon_by_ip') {
        $result = db_query("SELECT delta FROM {pollfield_votes}
          WHERE nid = :nid AND field_table=:field_table AND field_name=:field_name AND hostname = :hostname' AND field_name_delta=:field_name_delta",
          array(':nid'=>$t_nid, ':field_table'=>$field_table, ':field_name'=>$field_name, ':hostname'=>$hostname, ':field_name_delta'=>$field_name_delta));// delta is number of choice
        while ($db_votes = $result->fetchObject()) {
          $votes[] = $db_votes->delta;
        }
      }
      if ($anonymous == 'anon_non') {
        // $voted = 0;
      }
      if ($anonymous == 'anon_all') {
        // $voted = 1;
      }
      if ($anonymous == 'anon_by_cookie') {
        // add cookie
        $cookie_name = $field_table .'_'. $field_name .'_'. $field_name_delta;
        $cookie_collected_value = $_COOKIE[$cookie_name];

        $cookie_compare = array('cookie_name' => $cookie_name, 'cookie_value' => $cookie_collected_value);

        $cookie_compare_db = serialize($cookie_compare);

        $result = db_query("SELECT delta from {pollfield_votes}
          WHERE nid = :nid AND field_table = :field_table AND field_name = :field_name AND cookie = :cookie AND field_name_delta = :field_name_delta",
          array(':nid' => $t_nid, ':field_table' => $field_table, ':field_name' => $field_name, ':cookie' => $cookie_compare_db, ':field_name_delta' => $field_name_delta));
        while ($db_votes = $result->fetchObject()) {
          $votes[] = $db_votes->delta;
        }
      }
    }
  }
  return $votes;
}

/**
 * Build array of duration options
 *
 * The times in seconds that a pollfield can run for.
 */
function pollfield_duration_options() {
  $duration_options = array(0 => t('Unlimited')) + drupal_map_assoc(array(86400, 172800, 345600, 604800, 1209600, 2419200, 4838400, 9676800, 31536000), "format_interval");
  return $duration_options;
}
/**
 * Internal callback to validate starting vote totals.
 *
 * Check that this value is an integer.
 */
function _pollfield_is_digits_validate($element, &$form_state) {
  if ($element['#value'] != NULL) {
    if (!ctype_digit($element['#value'])) {
      form_error($element, t('The starting votes count must be a whole number.'));
    }
  }
}

/**
 * Implementation of hook_init().
 *
 * Executed at the begining of page requests to add custom css.
 */
function pollfield_init() {
  $css_file = drupal_get_path('module', 'pollfield') .'/pollfield.css';
  drupal_add_css($css_file, 'module');
	//drupal_add_js(drupal_get_path('module', 'pollfield') . '/pollfield.js');
}

/**
 * default field formatter function
 */
function theme_pollfield_default_formatter($elements){
	 // Node object
	
  $node = $elements['elements']['entity'];
	$delta = $elements['elements']['delta'];
  // Get the available choices for this poll
  $choices = unserialize($elements['elements']['item']['choice']);
	$item = $elements['elements']['item'];


  $output = '';
  if (!empty($choices)) {

    $pollfield_title = check_plain($elements['elements']['item']['question']);
    $poll_result = pollfield_build_results($elements['elements']);
		
    // Build voting form
   
		
    $form = drupal_get_form('pollfield_voting_form', $elements['elements']);
	
    $output  = '<div id="pollfield">';
    $output .= '<div id="pollfield-'. $node->nid .'-'. $delta .'" class="pollfield-form">';
    $output .= '<div class="pollfield-title">'. $pollfield_title .'</div>';
    $output .= $poll_result;
		
    $output .= render($form);
    $output .= '</div>';
    $output .= '</div>';
  }
  return $output;
}

/**
 * Build voting form
 *
 * Checks all the various rules associate with the current
 * pollfield and builds a form that lets you vote on
 * or cancel a pollfield.
 */
function pollfield_voting_form($form, &$form_state,$elements) {
  global $user;
	
  $form = array();
  $table = 'field_revision_'.$elements['field']['field_name'];
  $field_name = $elements['field']['field_name'];
  $field_name_delta = $elements['delta'];
  $items = $elements['item'];
  $active = $elements['item']['active'];
  $node = $elements['entity'];

  if ($active == 1) {
    // Get poll features
    if (is_array($elements['item']['poll_features'])) {
      $poll_features = $elements['item']['poll_features'];
    }
    else {
      $poll_features = unserialize($elements['item']['poll_features']);
    }
		
    // Get anonymous vote settings
    $anonymous = $elements['item']['anonymous'];
		
    // Check if user has voted
    $voted = pollfield_user_voted($elements);
		
    // If the user has voted, build the cancel vote form
    if ($voted) {
      if ($user->uid) {
        if ($poll_features['cancelvote_allow']) {//allow cancel vote
          $cancel=1;
          $form = array_merge($form, pollfield_voting_form_data($field_name_delta, $field_name, $node->nid, $table, $cancel,$items));
        }
      }
      else {
        if ($anonymous=='anon_non') {
          return NULL;
        }
        else {
          if ($poll_features['cancelvote_allow']) {
            $cancel = 1;
            $form = array_merge($form, pollfield_voting_form_data($field_name_delta, $field_name, $node->nid, $table, $cancel,$items));
          }
        }
      }
    }

    // If the user hasn't voted, build the vote form
    else {
      if ($user->uid == 0) {
        if ($anonymous == 'anon_non') {
          return NULL;
        }
      }
      if ($items) {
        $list = array();
        $choices = unserialize($items['choice']);
        if (!empty($choices)) {
          // Build choices array
          foreach ($choices as $delta => $choice) {
            if (!empty($choice['choice'])) {
              $list[$delta] = check_plain($choice['choice']);
            }
          }
          // Build single choice poll
          if ($poll_features['poll_type']=='0') {
            $form['choice'] = array('#type' => 'radios', '#title' => $items['question'], '#default_value' => -1, '#options' => $list);
          }
          // Build multiple choice poll
          if ($poll_features['poll_type']=='1') {
            $form['choice'] = array('#type' => 'checkboxes', '#title' => $items['question'], '#options' => $list);
          }
        }
      }
      $cancel = 0;
      $form = array_merge($form, pollfield_voting_form_data($field_name_delta, $field_name, $node->nid, $table, $cancel,$items));
    }
		
    return $form;
  }
  return NULL;
}

function pollfield_voting_form_data($field_name_delta, $field_name, $nid, $table, $cancel,$items) {
  $form['field_name_delta'] = array('#type' => 'hidden', '#value' => $field_name_delta);
  $form['field_name'] = array('#type' => 'hidden', '#value' => $field_name);
  $form['nid'] = array('#type' => 'hidden', '#value' => $nid);
	$form['item'] = array('#type' => 'hidden', '#value' => serialize($items));
  if ($cancel) {
    $form['vote'] = array('#type' => 'submit', '#value' => t('Cancel Vote'), '#submit' => array('pollfield_vote'));
  }
  else {
    $form['vote'] = array('#type' => 'submit', '#value' => t('Vote'), '#submit' => array('pollfield_vote'));
  }
  $form['table'] = array('#type' => 'hidden', '#value' => $table);
  $form['cancel'] = array('#type' => 'hidden', '#value' => $cancel);
  $form['#type'] = 'form';
  return $form;
}

/**
 * Build the results display
 *
 * @param array $element
 *
 * @return pollfield_result
 *   A formatted HTML string of the appropriate pollfield
 *   result display. Will output empty HTML structure if
 *   the user can't view results b/c of permissions.
 */
function pollfield_build_results($elements) {

  // Node object
  $node = $elements['entity'];

  $field_name = $elements['field']['field_name'];

  // :TODO: This should be renamed to field_delta
  // But, it's everywhere in the module. Do it in one fell swoop.
  $field_name_delta = $elements['delta'];

  // Get the available choices for this poll
  $choices = unserialize($elements['item']['choice']);

  // Determine if the user voted on this node.
  $field_table = $node->type;
  $user_voted = pollfield_user_voted($elements);
  $user_votes = pollfield_user_votes($elements);

  $poll_result = NULL;
  $choices_array = array();

  // Array of vote totals for each choice.
  $votes = pollfield_sum_all_votes($node , $choices, $elements);

  // Total of all votes.
  $sum = array_sum($votes);
	
  foreach ($choices as $delta => $choice) {

    if (!empty($choice['choice'])) {
			
      // :TODO: Is this the best place to do this?
      $choice['choice'] = check_plain($choice['choice']);

      // Don't divide by zero.
      if ($sum > 0) {
        $percent = round(floatval(($votes[$delta]*100.0)/$sum), 1);
      }
      else {
        $percent = 0;
      }
			
      // :TODO: Make this a theme function
      $percent_string = $percent .'% ('. format_plural($votes[$delta], '1 vote', '@count votes') .')';
			
      // Find out if the user voted on this choice
      $user_choice = FALSE;
      if (is_array($user_votes)) {
        if (in_array($delta, $user_votes)) {
          $user_choice = TRUE;
        }
      }

      // If the user has permission to view results and
      // this node allows results viewing, show them.
      $permission='view pollfield results '. $field_name;
      if (user_access($permission)) {
      	
        if ( $user_voted || pollfield_display_results_before_vote($elements['item'])) {
          
					$variables['choice']=$choice;$variables['percent']=$percent;
					$variables['percent_string']=$percent_string;$variables['user_choice']=$user_choice;
					$variables['show_results']=TRUE;
					
					$poll_result .= theme('pollfield_row', $variables);
        }
      }
      else {
        if ( $user_voted ) {
          $show_results = FALSE;
					$variables['choice']=$choice;$variables['percent']=$percent;
					$variables['percent_string']=$percent_string;$variables['user_choice']=$user_choice;
					$variables['show_results']=$show_results;
					
          $poll_result .= theme('pollfield_row', $variables);
        }
      }
    }
  }
	
  return $poll_result;
}

/**
 * Return an array of vote totals for each choice in a pollfield.
 */
function pollfield_sum_all_votes($node, $choices, $elements) {
  $type = $elements['entity']->type;
  $field = $elements['field']['field_name'];
  $field_name_delta = $elements['delta'];
	$table = 'field_revision_'.$field;
  // This check is required until we can stop empty pollfields from
  // requesting a vote count, which would be more efficient.
  $choice_count = array();
  if (is_array($choices)) {
    foreach ($choices as $delta => $group) {
      // Count user submitted votes
      $choice_count[] = $choices[$delta]['votes'] + db_query("SELECT count(*) FROM {pollfield_votes} WHERE nid = :nid AND delta= :delta
        AND field_table=:field_table AND field_name=:field_name AND field_name_delta=:field_name_delta", 
        array(':nid'=>$node->nid, ':delta'=>$delta, ':field_table'=>$table, ':field_name'=>$field, ':field_name_delta'=>$field_name_delta))
				->fetchField();
    }
  }
  return $choice_count;
}

/**
 * Return a sum of the total votes on a pollfield.
 */
function pollfield_sum_starting_votes($choices) {
  // This check is required until we can stop empty pollfields from
  // requesting a vote count, which would be more efficient.
  if (is_array($choices)) {
    foreach ($choices as $delta => $group) {
      // Count starting votes.
      $total_votes = $total_votes + $choices[$delta]['votes'];
    }
    return $total_votes;
  }
}
/**
 * Does this node allow the user to view results?
 *
 * @param $item array
 *   Array of the pollfield information
 *
 * @return
 *   Boolean value. Defaults to FALSE, meaning you can't view the results
 *   before you vote on the pollfield.
 */
function pollfield_display_results_before_vote($item) {
  $poll_features = unserialize($item['poll_features']);
  if ($poll_features['result_allow']) {
    return TRUE;
  }
  return FALSE;
}
/**
 * choices field formatter function
 */
function theme_pollfield_choices_formatter($item,$entity){
	// Node object
   // Node object
	
  $node = $elements['elements']['entity'];
	$delta = $elements['elements']['delta'];
  // Get the available choices for this poll
  $choices = unserialize($elements['elements']['item']['choice']);
	
	
	
  $output = '';
  if (!empty($choices)) {

    $pollfield_title = check_plain($elements['elements']['item']['question']);
    $poll_result = pollfield_build_results($elements['elements']);
		
    // Build voting form
   
		
    $form = drupal_get_form('pollfield_voting_form', $elements['elements']);
	
    $output  = '<div id="pollfield">';
    $output .= '<div id="pollfield-'. $node->nid .'-'. $delta .'" class="pollfield-form">';
    $output .= '<div class="pollfield-title">'. $pollfield_title .'</div>';
    $output .= '</div>';
    $output .= '</div>';
  }
  return $output;
}
/**
 * results field formatter function
 */
function theme_pollfield_results_formatter($item,$entity){
	 // Node object
	
  $node = $elements['elements']['entity'];
	$delta = $elements['elements']['delta'];
  // Get the available choices for this poll
  $choices = unserialize($elements['elements']['item']['choice']);
	
	
	
  $output = '';
  if (!empty($choices)) {

    $pollfield_title = check_plain($elements['elements']['item']['question']);
    $poll_result = pollfield_build_results($elements['elements']);
		
    // Build voting form
   
		
    $form = drupal_get_form('pollfield_voting_form', $elements['elements']);
	
    $output  = '<div id="pollfield">';
    $output .= '<div id="pollfield-'. $node->nid .'-'. $delta .'" class="pollfield-form">';
    $output .= '<div class="pollfield-title">'. $pollfield_title .'</div>';
    $output .= $poll_result;
    $output .= '</div>';
    $output .= '</div>';
  }
  return $output;
}
/**
 * runtime field formatter function
 */
function theme_pollfield_runtime_formatter($item,$entity){
	 $node = $elements['elements']['entity'];
	$delta = $elements['elements']['delta'];
  // Get the available choices for this poll
  $choices = unserialize($elements['elements']['item']['choice']);
	
	
	
  $output = '';
  if (!empty($choices)) {

    if ($elements['elements']['item']['runtime']>0) {
      $runtime = t('!duration duration of poll in seconds', array('!duration' => $elements['elements']['item']['runtime']));
    }
    else{
      $runtime = t('Unlimited poll duration.');
    }
    $out = '<div class="pollfield-runtime">'. check_plain($runtime) .'</div>';
    return $out;

  }
  return $output;
}
/**
 * question field formatter function
 */
function theme_pollfield_question_formatter($item,$entity){
	 $node = $elements['elements']['entity'];
	$delta = $elements['elements']['delta'];
  // Get the available choices for this poll
  $choices = unserialize($elements['elements']['item']['choice']);
	
	
	
  $output = '';
  if (!empty($choices)) {

    
		
    $output = '<div class="pollfield-questions">';

    if ($elements['elements']['item']['question']!="' '") {
      $output .= '<div class="pollfield-row">'. check_plain($elements['elements']['item']['question']) .'</div>';
    }
    $output .= '</div>';

   
 
  }
  return $output;
}
/**
 * Implementation of hook_theme().
 *
 * Define the theme hooks for pollfield.
 *
 * These setup the various display styles you can choose
 * in the CCK display settings for this field.
 */
function pollfield_theme() {

  return array(    
    'pollfield_default_formatter' => array(
      'variables' => array('elements'),
    ),
    'pollfield_row' => array(
      'variables' => array('choice' => NULL, 'user_choice' => FALSE, 'percent' => NULL, 'percent_string' => NULL),
    ),
    'pollfield_results_formatter' => array(
      'variables' => array('elements'),
    ),
    'pollfield_question_formatter' => array(
      'variables' => array('elements'),
    ),
    'pollfield_runtimeformatter_' => array(
      'variables' => array('elements'),
    ),
    'pollfield_choices_formatter' => array(
      'variables' => array('elements'),
    ),
  );
}
/**
 * Theme function for an single results row.
 *
 * @param $choice string
 *   The choice text string
 * @param $user_choice boolean
 *   Is this value the user's current choice.
 * @param $percent integer
 *   Pecentage of the total votes this choice represents
 * @param $percent_string string
 *   Formatted string that describes how many votes this percentage represents.
 * @param $show_results boolean
 *   Handler for situations where people are allowed to vote on a poll
 *   but don't have the permission to view results. Defaults to TRUE, which
 *   allows the user to see results.
 *
 * @return
 *   Formatted HTML string of one choice result in a pollfield
 */
function theme_pollfield_row($variables) {
 
  // Mark the user's vote
  $row_class='';
  if ($variables['user_choice']) {
    $row_class = ' pollfield-chosen';
  }
  $output  = '<div class="pollfield-row'. $row_class .'">';
  $output .= '<div class="text">'. $variables['choice']['choice'] .'</div>';
  if ($variables['show_results']) {
    $output .= '<div class="barcell">';
    $output .= '<div class="bar"><div class="pollfield-foreground" style="width: '. $variables['percent'] .'%;"></div></div>';
    $output .= '</div>';
    $output .= '<div class="pollfield-percent">'. $variables['percent_string'] .'</div>';
  }
  $output .= '</div>';
  return $output;
}
/**
 * Implementation of hook_perm().
 *
 * Defines the permission options for pollfields.
 */
function pollfield_permission() {
  // Get CCK fields
  
  $fields_query = db_query("SELECT field_name FROM {field_config} WHERE type='pollfield_poll'");
	// Build a permission for each pollfield enabled content type
  $permission = array();
	while ($field_name=$fields_query->fetchField()){
		$view_result = 'view pollfield results '. $field_name;
		$admin_pollfield = 'admin pollfield '. $field_name;
		$permission[$view_result]=array('title'=>$field_name.t(' - View pollfield results ').$field_name);
    $permission[$admin_pollfield]=array('title'=>$field_name.t(' - Full admin access to pollfield edit options '));
		
	}
	
  return $permission;
}

/**
 * Clear the Drupal cache
 *
 * The cache is generally cleared after a vote is recorded
 *
 * TODO - really? clear the entire cache every time a vote is recorded?
 */
function pollfield_clear($node) {
  $cid = 'field:node:'. $node->nid;
  cache_clear_all($cid, db_table_exists('cache_field') ? 'cache_field' : 'cache', TRUE);
  cache_clear_all();
}


/**
 * Implementation of hook_cron().
 * Closes pollfields that have exceeded their allowed runtime.
 */
function pollfield_cron() {
  $time = time();
	$fields_query = db_query("SELECT field_name FROM {field_config} WHERE type='pollfield_poll'");
	while ($field_name=$fields_query->fetchField()){
		$query="SELECT p.* FROM {field_revision_".$field_name."} p LEFT JOIN {node} n ON n.nid=p.entity_id WHERE (n.created + p.".$field_name."_runtime)<".$time;
		$polls_query = db_query($query);
		while ($polls=$polls_query->fetchObject()){
			$query_update = "UPDATE {field_revision_".$field_name."} SET ".$field_name."_active = 0 WHERE entity_id=".$polls->entity_id." AND delta = ".$polls->delta;
			db_query($query_update);
			$query_update = "UPDATE {field_data_".$field_name."} SET ".$field_name."_active = 0 WHERE entity_id=".$polls->entity_id." AND delta = ".$polls->delta;
			db_query($query_update);
		}
	}
  
}
